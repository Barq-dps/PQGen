<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Challenge Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        h1, h2, h3, h4 {
            margin-top: 0;
        }
        .hidden {
            display: none;
        }
        .section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #upload-status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
        }
        .challenge-list-item {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 15px;
            transition: transform 0.2s;
        }
        .challenge-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .challenge-list-item h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        .challenge-meta {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .difficulty-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .difficulty-easy {
            background-color: #e6f7e6;
            color: #27ae60;
        }
        .difficulty-medium {
            background-color: #fff7e6;
            color: #f39c12;
        }
        .difficulty-hard {
            background-color: #ffe6e6;
            color: #e74c3c;
        }
        .challenge-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            background-color: #e6f0f7;
            color: #3498db;
        }
        #topics-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            list-style: none;
            padding: 0;
        }
        #topics-list li {
            background-color: #e6f0f7;
            color: #3498db;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
        }
        .option-btn {
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 10px;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .option-btn:hover:not(:disabled) {
            background-color: #e9ecef;
            border-color: #ced4da;
        }
        .option-btn.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .option-btn.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .option-btn.correct-answer-reveal {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
            opacity: 0.7;
        }
        .option-btn.eliminated {
            opacity: 0.5;
            text-decoration: line-through;
        }
        pre, code {
            background-color: #f8f9fa;
            border: 1px solid #eaecef;
            border-radius: 3px;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        textarea {
            width: 100%;
            min-height: 200px;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: vertical;
        }
        #evaluation-result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
        }
        .status-correct {
            color: #155724;
            font-weight: bold;
        }
        .status-incorrect {
            color: #721c24;
            font-weight: bold;
        }
        .status-error {
            color: #856404;
            font-weight: bold;
        }
        #correct-solution-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #28a745;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .btn {
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Programming Challenge Generator</h1>
        <p>Upload a PDF to generate programming challenges based on its content</p>
    </header>

    <div class="container">
        <!-- Upload Section -->
        <div id="upload-section" class="section">
            <h2>Upload PDF Document</h2>
            <form id="upload-form" onsubmit="return false;">
                <input type="file" id="pdf-file" accept=".pdf" required>
                <button type="button" id="generate-btn" class="btn">Generate Challenges</button>
            </form>
            <div id="upload-status" style="display: none;"></div>
        </div>

        <!-- Challenges List Section -->
        <div id="challenges-section" class="section hidden">
            <h2>Generated Challenges</h2>
            <div>
                <h3>Topics Extracted</h3>
                <ul id="topics-list"></ul>
            </div>
            <div id="challenges-list"></div>
        </div>

        <!-- Challenge Detail Section -->
        <div id="challenge-detail-section" class="section hidden">
            <button id="back-to-challenges" class="btn">‚Üê Back to Challenges</button>
            <h2 id="challenge-title">Challenge Title</h2>
            <div id="challenge-difficulty" class="challenge-meta"></div>
            <div id="challenge-description"></div>

            <!-- Multiple Choice Area -->
            <div id="mcq-area" class="hidden">
                <div id="mcq-options-container"></div>
            </div>

            <!-- Debugging Area -->
            <div id="debugging-area" class="hidden">
                <h3>Buggy Code</h3>
                <pre id="buggy-code-display"></pre>
                <h3>Your Solution</h3>
                <textarea id="code-editor"></textarea>
                <button id="submit-code-debug" class="btn">Submit Solution</button>
            </div>

            <!-- General Coding Area -->
            <div id="general-coding-area" class="hidden">
                <h3>Code</h3>
                <textarea id="general-code-editor"></textarea>
                <button id="submit-code-general" class="btn">Submit Solution</button>
            </div>

            <button id="hint-button" class="btn" style="display: none; margin-top: 15px;">Get Hint</button>
            <button id="reveal-solution-button" class="btn" style="display: none; margin-top: 15px;">Reveal Solution</button>

            <!-- Evaluation Result Area -->
            <div id="evaluation-result" class="hidden">
                <div id="result-status"></div>
                <div id="result-message"></div>
                <div id="result-explanation"></div>
            </div>

            <!-- Correct Solution Container -->
            <div id="correct-solution-container" class="hidden">
                <h3>Correct Solution</h3>
                <pre id="correct-code-display"></pre>
                <div id="correct-code-explanation"></div>
            </div>
        </div>
    </div>

    <!-- Inline JavaScript for direct form handling -->
    <script>
    // Directly include the core functionality to avoid loading issues
    document.addEventListener('DOMContentLoaded', function() {
        const uploadForm = document.getElementById('upload-form');
        const generateBtn = document.getElementById('generate-btn');
        const pdfFile = document.getElementById('pdf-file');
        const uploadStatus = document.getElementById('upload-status');
        const API_BASE_URL = "http://localhost:5000";
        
        if (generateBtn) {
            generateBtn.addEventListener('click', function() {
                console.log("Generate button clicked");
                
                try {
                    // Basic form validation
                    if (!pdfFile || !pdfFile.files || !pdfFile.files.length) {
                        if(uploadStatus) {
                            uploadStatus.textContent = "Please select a PDF file.";
                            uploadStatus.style.display = 'block';
                        }
                        return;
                    }
                    
                    // Show processing status
                    if(uploadStatus) {
                        uploadStatus.innerHTML = '<div class="spinner"></div> Processing PDF and generating challenges... This may take a few minutes.';
                        uploadStatus.style.display = 'block';
                    }
                    
                    // Create form data and send request
                    const formData = new FormData();
                    formData.append("file", pdfFile.files[0]);
                    
                    // Use fetch API directly
                    fetch(`${API_BASE_URL}/api/upload`, {
                        method: "POST",
                        body: formData,
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(data => {
                                throw new Error(data.error || `HTTP error! status: ${response.status}`);
                            });
                        }
                        return response.json();
                    })
                    .then(result => {
                        if (result.document_id) {
                            if(uploadStatus) {
                                uploadStatus.innerHTML = '<div class="spinner"></div> Document uploaded successfully. Processing challenges...';
                            }
                            // Start polling for status
                            pollDocumentStatus(result.document_id);
                        } else {
                            if(uploadStatus) uploadStatus.textContent = "Error: No document ID returned from server.";
                        }
                    })
                    .catch(error => {
                        console.error("Error uploading PDF:", error);
                        if(uploadStatus) {
                            uploadStatus.textContent = `Error: ${error.message}`;
                            uploadStatus.style.display = 'block';
                        }
                    });
                } catch (error) {
                    console.error("Critical error:", error);
                    if(uploadStatus) {
                        uploadStatus.textContent = `Critical error: ${error.message}`;
                        uploadStatus.style.display = 'block';
                    }
                }
            });
        }
        
        // Polling function for document status
        let pollingInterval = null;
        
        function pollDocumentStatus(documentId) {
            console.log(`Starting to poll status for document: ${documentId}`);
            
            // Clear any existing polling interval
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            
            // Function to check document status
            const checkStatus = function() {
                fetch(`${API_BASE_URL}/api/documents/${documentId}/status`)
                .then(response => response.json())
                .then(result => {
                    console.log(`Document status: ${result.status}`);
                    
                    if (result.status === "completed") {
                        // Stop polling once processing is complete
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        
                        // Update status message
                        if(uploadStatus) {
                            uploadStatus.textContent = `PDF processing complete. Fetching challenges...`;
                        }
                        
                        // Fetch challenges
                        fetchAndDisplayChallengeList(documentId);
                    } else if (result.status === "error") {
                        // Stop polling on error
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        
                        if(uploadStatus) uploadStatus.textContent = `Error processing PDF: ${result.error || "Unknown error"}`;
                    } else {
                        // Still processing, update status message
                        if(uploadStatus) {
                            uploadStatus.innerHTML = '<div class="spinner"></div> Still processing PDF... This may take a few minutes.';
                        }
                    }
                })
                .catch(error => {
                    console.error("Error checking document status:", error);
                    if(uploadStatus) uploadStatus.textContent = `Error checking status: ${error.message}`;
                    
                    // Stop polling on error
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                });
            };
            
            // Check status immediately
            checkStatus();
            
            // Then check periodically
            pollingInterval = setInterval(checkStatus, 2000); // Poll every 2 seconds
        }
        
        function fetchAndDisplayChallengeList(documentId) {
            const challengesSection = document.getElementById("challenges-section");
            const topicsList = document.getElementById("topics-list");
            const challengesListContainer = document.getElementById("challenges-list");
            
            fetch(`${API_BASE_URL}/api/documents/${documentId}/challenges`)
            .then(response => response.json())
            .then(result => {
                const challenges = result.challenges || [];
                const topics = result.topics || [];
                
                console.log(`Fetched ${challenges.length} challenges for ${topics.length} topics`);
                
                if(uploadStatus) {
                    uploadStatus.textContent = `Found ${challenges.length} challenges across ${topics.length} topics.`;
                    setTimeout(() => {
                        if(uploadStatus) uploadStatus.style.display = 'none';
                    }, 3000);
                }
                
                if(topicsList) {
                    topicsList.innerHTML = "";
                    if (topics && topics.length > 0) {
                        topics.forEach(topic => {
                            const li = document.createElement("li");
                            li.textContent = topic;
                            topicsList.appendChild(li);
                        });
                    } else {
                        topicsList.innerHTML = "<li>No topics extracted.</li>";
                    }
                }
                
                if(challengesListContainer) {
                    challengesListContainer.innerHTML = "";
                    if (challenges && challenges.length > 0) {
                        challenges.forEach((challenge, index) => {
                            const challengeItem = document.createElement("div");
                            challengeItem.classList.add("challenge-list-item");
                            
                            // Use question if available, otherwise fall back to question_text
                            const questionText = challenge.question || challenge.question_text || "No question text";
                            
                            // Get difficulty and capitalize first letter
                            const difficulty = challenge.difficulty || "medium";
                            const displayDifficulty = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                            
                            // Add difficulty badge with appropriate color
                            const difficultyClass = `difficulty-${difficulty.toLowerCase()}`;
                            
                            challengeItem.innerHTML = `
                                <h4>${escapeHtml(challenge.topic || "Challenge")} #${index + 1}</h4>
                                <p>${escapeHtml(questionText.substring(0, 100))}...</p>
                                <div class="challenge-meta">
                                    <span class="difficulty-badge ${difficultyClass}">${displayDifficulty}</span>
                                    <span class="challenge-type">${challenge.type || "Unknown"}</span>
                                </div>
                                <button class="btn view-challenge-btn" data-index="${index}">View Challenge</button>
                            `;
                            challengesListContainer.appendChild(challengeItem);
                        });
                        
                        // Store challenges in a global variable for access
                        window.allFetchedChallenges = challenges;
                        
                        // Add event listeners to view buttons
                        document.querySelectorAll(".view-challenge-btn").forEach(button => {
                            button.addEventListener("click", (e) => {
                                const challengeIndex = parseInt(e.target.dataset.index);
                                displayChallengeDetail(window.allFetchedChallenges[challengeIndex]);
                            });
                        });
                    } else {
                        challengesListContainer.innerHTML = "<p>No challenges found for this document.</p>";
                    }
                }
                
                // Show challenges section
                if(challengesSection) challengesSection.classList.remove("hidden");
                if(document.getElementById("upload-section")) document.getElementById("upload-section").classList.add("hidden");
                if(document.getElementById("challenge-detail-section")) document.getElementById("challenge-detail-section").classList.add("hidden");
            })
            .catch(error => {
                console.error("Error fetching challenges:", error);
                if(uploadStatus) uploadStatus.textContent = `Error: ${error.message}`;
                if(challengesListContainer) challengesListContainer.innerHTML = "<p>Failed to fetch challenges.</p>";
                if(challengesSection) challengesSection.classList.remove("hidden");
                if(document.getElementById("upload-section")) document.getElementById("upload-section").classList.add("hidden");
            });
        }
        
        function displayChallengeDetail(challenge) {
            const challengeDetailSection = document.getElementById("challenge-detail-section");
            const challengeTitle = document.getElementById("challenge-title");
            const challengeDescription = document.getElementById("challenge-description");
            const challengeDifficulty = document.getElementById("challenge-difficulty");
            const mcqArea = document.getElementById("mcq-area");
            const mcqOptionsContainer = document.getElementById("mcq-options-container");
            const debuggingArea = document.getElementById("debugging-area");
            const buggyCodeDisplay = document.getElementById("buggy-code-display");
            const codeEditor = document.getElementById("code-editor");
            const generalCodingArea = document.getElementById("general-coding-area");
            const generalCodeEditor = document.getElementById("general-code-editor");
            const hintButton = document.getElementById("hint-button");
            const evaluationResultArea = document.getElementById("evaluation-result");
            const correctSolutionContainer = document.getElementById("correct-solution-container");
            
            if (!challenge) {
                console.error("No challenge data to display");
                return;
            }
            
            // Store current challenge for later use
            window.currentChallenge = challenge;
            
            console.log("Displaying challenge:", challenge);
            
            if(evaluationResultArea) evaluationResultArea.classList.add("hidden");
            if(correctSolutionContainer) correctSolutionContainer.classList.add("hidden");
            
            if(challengeTitle) challengeTitle.textContent = escapeHtml(challenge.topic || "Challenge Details");
            
            // Use question if available, otherwise fall back to question_text
            const questionText = challenge.question || challenge.question_text || "No question text";
            if(challengeDescription) challengeDescription.innerHTML = `<p>${escapeHtml(questionText)}</p>`;
            
            // Display difficulty if available
            if(challengeDifficulty) {
                const difficulty = challenge.difficulty || "medium";
                const displayDifficulty = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                const difficultyClass = `difficulty-${difficulty.toLowerCase()}`;
                
                challengeDifficulty.innerHTML = `<span class="difficulty-badge ${difficultyClass}">${displayDifficulty}</span>`;
                challengeDifficulty.classList.remove("hidden");
            }
            
            let type = "coding";
            if (challenge.options && challenge.options.length > 0) type = "mcq";
            else if (challenge.buggy_code) type = "debug";
            else if (challenge.code_stub || challenge.function_template) type = "coding";
            
            challenge.type = type;
            
            if(mcqArea) mcqArea.classList.add("hidden");
            if(debuggingArea) debuggingArea.classList.add("hidden");
            if(generalCodingArea) generalCodingArea.classList.add("hidden");
            if(hintButton) hintButton.style.display = "none";
            
            if (type === "mcq" && mcqArea && mcqOptionsContainer) {
                mcqArea.classList.remove("hidden");
                mcqOptionsContainer.innerHTML = "";
                
                // Handle both array of objects and array of strings for options
                const options = challenge.options || [];
                options.forEach((option, index) => {
                    const button = document.createElement("button");
                    button.classList.add("btn", "option-btn");
                    button.dataset.index = index;
                    
                    // Handle both {text: "option"} and "option" formats
                    const optionText = typeof option === 'object' ? (option.text || '') : option;
                    button.textContent = escapeHtml(optionText);
                    
                    button.addEventListener("click", handleMcOptionClick);
                    mcqOptionsContainer.appendChild(button);
                });
                
                if (hintButton && (challenge.hint || challenge.options.length > 2)) {
                     hintButton.style.display = "inline-block";
                }
            } else if (type === "debug" && debuggingArea && buggyCodeDisplay && codeEditor) {
                debuggingArea.classList.remove("hidden");
                
                // Use buggy_code if available, otherwise fall back to code_stub
                let codeToDisplay = challenge.buggy_code || challenge.code_stub || "";
                
                const bugCommentRegex = /^.*\/\/\s*BUG[:\s].*$/im;
                const match = codeToDisplay.match(bugCommentRegex);
                if (match) {
                    window.actualHintForCurrentDebugChallenge = match[0].trim();
                    codeToDisplay = codeToDisplay.replace(bugCommentRegex, "").trim();
                }
                
                buggyCodeDisplay.textContent = codeToDisplay;
                codeEditor.value = codeToDisplay;
                if(hintButton) hintButton.style.display = "inline-block";
            } else if (generalCodingArea && generalCodeEditor) { 
                generalCodingArea.classList.remove("hidden");
                
                // Use function_template if available, otherwise fall back to code_stub
                generalCodeEditor.value = challenge.function_template || challenge.code_stub || "";
                
                if (hintButton && challenge.hint) {
                    hintButton.style.display = "inline-block";
                }
            }
            
            // Show challenge detail section
            if(challengeDetailSection) challengeDetailSection.classList.remove("hidden");
            if(document.getElementById("upload-section")) document.getElementById("upload-section").classList.add("hidden");
            if(document.getElementById("challenges-section")) document.getElementById("challenges-section").classList.add("hidden");
            
            // Add back button event listener
            const backToChallengesButton = document.getElementById("back-to-challenges");
            if (backToChallengesButton) {
                backToChallengesButton.addEventListener("click", () => {
                    if(document.getElementById("challenges-section")) document.getElementById("challenges-section").classList.remove("hidden");
                    if(document.getElementById("challenge-detail-section")) document.getElementById("challenge-detail-section").classList.add("hidden");
                    if(document.getElementById("upload-section")) document.getElementById("upload-section").classList.add("hidden");
                });
            }
            
            // Add hint button event listener
            if (hintButton) {
                hintButton.addEventListener("click", handleHint);
            }
        }
        
        function handleMcOptionClick(event) {
            const currentChallenge = window.currentChallenge;
            const evaluationResultArea = document.getElementById("evaluation-result");
            const resultStatus = document.getElementById("result-status");
            const resultExplanation = document.getElementById("result-explanation");
            const mcqOptionsContainer = document.getElementById("mcq-options-container");
            
            if (!currentChallenge || currentChallenge.type !== "mcq" || !evaluationResultArea || !resultStatus || !resultExplanation || !mcqOptionsContainer) return;
            
            const selectedIndex = parseInt(event.target.dataset.index);
            
            // Handle both array of objects with correct property and correct_option index
            let correctIndex = -1;
            if (Array.isArray(currentChallenge.options)) {
                if (typeof currentChallenge.options[0] === 'object') {
                    // Array of objects with correct property
                    correctIndex = currentChallenge.options.findIndex(opt => opt.correct);
                } else if (typeof currentChallenge.correct_index === 'number') {
                    // Array of strings with correct_index
                    correctIndex = currentChallenge.correct_index;
                } else if (typeof currentChallenge.correct_option === 'number') {
                    // Array of strings with correct_option index
                    correctIndex = currentChallenge.correct_option;
                }
            }
            
            evaluationResultArea.classList.remove("hidden");
            resultExplanation.innerHTML = "";
            
            mcqOptionsContainer.querySelectorAll(".option-btn").forEach(btn => {
                btn.disabled = true;
                btn.classList.remove("correct", "incorrect", "correct-answer-reveal");
            });
            
            if (selectedIndex === correctIndex) {
                resultStatus.textContent = "Correct!";
                resultStatus.className = "status-correct";
                event.target.classList.add("correct");
                if (currentChallenge.explanation) {
                    resultExplanation.innerHTML = `<p>${escapeHtml(currentChallenge.explanation)}</p>`;
                }
            } else {
                resultStatus.textContent = "Incorrect.";
                resultStatus.className = "status-incorrect";
                event.target.classList.add("incorrect");
                const correctButton = mcqOptionsContainer.querySelector(`.option-btn[data-index="${correctIndex}"]`);
                if (correctButton) correctButton.classList.add("correct-answer-reveal");
                if (currentChallenge.explanation) {
                    resultExplanation.innerHTML = `<p>${escapeHtml(currentChallenge.explanation)}</p>`;
                }
            }
        }
        
        function handleHint() {
            const currentChallenge = window.currentChallenge;
            const hintButton = document.getElementById("hint-button");
            const evaluationResultArea = document.getElementById("evaluation-result");
            const resultExplanation = document.getElementById("result-explanation");
            const mcqOptionsContainer = document.getElementById("mcq-options-container");
            
            if (!currentChallenge || !hintButton) return;
            
            if (currentChallenge.type === "mcq") {
                if (window.hintUsedForMcq) return;
                window.hintUsedForMcq = true;
                
                // For MCQ, eliminate one wrong option
                const options = currentChallenge.options || [];
                let correctIndex = -1;
                
                if (typeof options[0] === 'object') {
                    correctIndex = options.findIndex(opt => opt.correct);
                } else if (typeof currentChallenge.correct_index === 'number') {
                    correctIndex = currentChallenge.correct_index;
                } else if (typeof currentChallenge.correct_option === 'number') {
                    correctIndex = currentChallenge.correct_option;
                }
                
                if (correctIndex >= 0 && mcqOptionsContainer) {
                    // Find wrong options
                    const wrongIndices = [];
                    for (let i = 0; i < options.length; i++) {
                        if (i !== correctIndex) {
                            wrongIndices.push(i);
                        }
                    }
                    
                    // Randomly select one wrong option to eliminate
                    if (wrongIndices.length > 0) {
                        const indexToEliminate = wrongIndices[Math.floor(Math.random() * wrongIndices.length)];
                        const buttonToDisable = mcqOptionsContainer.querySelector(`.option-btn[data-index="${indexToEliminate}"]`);
                        if (buttonToDisable) {
                            buttonToDisable.disabled = true;
                            buttonToDisable.classList.add("eliminated");
                            buttonToDisable.title = "Eliminated by hint";
                        }
                    }
                }
            } else if (currentChallenge.type === "debug") {
                // For debugging, show the bug comment
                if (window.actualHintForCurrentDebugChallenge && resultExplanation) {
                    resultExplanation.innerHTML = `<p><b>Hint:</b> ${escapeHtml(window.actualHintForCurrentDebugChallenge)}</p>`;
                    evaluationResultArea.classList.remove("hidden");
                } else if (currentChallenge.hint && resultExplanation) {
                    resultExplanation.innerHTML = `<p><b>Hint:</b> ${escapeHtml(currentChallenge.hint)}</p>`;
                    evaluationResultArea.classList.remove("hidden");
                }
            } else if (currentChallenge.hint && resultExplanation) {
                // For other types, show the hint text
                resultExplanation.innerHTML = `<p><b>Hint:</b> ${escapeHtml(currentChallenge.hint)}</p>`;
                evaluationResultArea.classList.remove("hidden");
            }
        }
        
        // Helper function to escape HTML
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    });
    </script>
</body>
</html>
